# 강한 결합: 복잡하게 얽혀서 풀 수 없는 구조

논의 주제

- 상속을 사용하는가, 사용한다면 어떤 목적으로

## 8.2 다양한 강한 결합 사례와 대처 방법

### 8.2.1 상속과 관련된 강한 결합

상속은 주의해서 다루지 않으면 강한 결합 구조를 유발하는 문법이다.

- 책에서는 **상속 자체**를 권장하지 않습니다

#### 슈퍼 클래스 의존

단일 공격과 2회 연속 공격이 있는 사양, PhysicalAttack

```java
class PhysicalAttack {
    // 단일 공격
 singleAttackDamage(): number {
  return 5; 
 }
    // 2회 공격
 doubleAttackDamage(): number { 
  return 10;
 }
}

// 직업이 격투가면 추가 데미지
class FighterPhysicalAttack extends PhysicalAttack {
 @Override
 singleAttackDamage() {
  return super.singleAttackDamage() + 20; // 25
 }
 @Override
 doubleAttackDamage() {
  return super.doubleAttackDamage() + 10; // 20
 }
}
```

만약 PhysicalAttack의 doulbeAttackDamage가 `singleAttackDamage`를 두번 실행하는 메서드로 바뀔 경우 FighterPhysicalAttack 에서는 이제 다르게 계산이 된다.

```java
class PhysicalAttack {
 int singleAttackDamage() { 
    return 5; 
  }
 int doubleAttackDamage() { 
    return this.singleAttackDamage() + this.singleAttackDamage(); // 2번 공격하는 방식
  }
}

class FighterPhysicalAttack extends PhysicalAttack {
 int singleAttackDamage() {
  return super.singleAttackDamage() + 20; // 25
 }
 int doubleAttackDamage() {
  return super.doubleAttackDamage() + 10;  // 20이 아니라 30
 }
}
```

#### 상속보단 컴포지션

슈퍼 클래스 의존으로 인한 강한 결합을 피하려면 **컴포지션**을 사용하는 것이 좋다.

- 컴포지션: 사용하고 싶은 클래스를 코드 8.9처럼 private 인스턴스 변수로 갖고 사용

```java
class PhysicalAttack {
 int singleAttackDamage() { 
    return 5;
  }
 int doubleAttackDamage() { 
    return singleAttackDamage() + this.singleAttackDamage();
  }
}

class FighterPhysicalAttack {
  private final PhysicalAttack physicalAttack;

 int singleAttackDamage() { 
  return physicalAttack.singleAttackDamage() + 20;
 }
 int doubleAttackDamage() { 
  return physicalAttack.doubleAttackDamage() + 10;
 }
}
```

<https://velog.io/@haryan248/%EB%82%B4-%EC%BD%94%EB%93%9C%EA%B0%80-%EA%B7%B8%EB%A0%87%EA%B2%8C-%EC%9D%B4%EC%83%81%ED%95%9C%EA%B0%80%EC%9A%94-8%EC%9E%A5-%EC%A0%95#2-%EB%8B%A4%EC%96%91%ED%95%9C-%EA%B0%95%ED%95%9C-%EA%B2%B0%ED%95%A9-%EC%82%AC%EB%A1%80%EC%99%80-%EB%8C%80%EC%B2%98-%EB%B0%A9%EB%B2%95>
